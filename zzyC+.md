# C++

## 变量

### 全局变量

**定义：**在所有函数的外部声明的变量，称为全局变量。

### 局部变量

**定义：**在函数或一个代码块内部声明的变量，称为局部变量。

### 形式参数

**定义：**在函数参数的定义中声明的变量，称为形式参数。

## 常量

**定义：**1、常量是固定值，在程序执行期间不会改变，这些固定的值，称作字面量。

2、常量可以是任何的基本数据类型，可分为整形数字、字符、字符串或者布尔值。

3、常量就像是常规的变量，只不过常量的值在定义后不能修改。

### 整形常量

整形常量可以是十进制，八进制或十六进制的常量。

前缀制定基数：0x或0X表示16进制，0表示八进制，不带前缀则默认表示十进制。

整数常量也可以带一个后缀，后缀是U和L的组合，U表示无符号整数（

unsigned），L表示长整数（long）。

后缀可以使大写也可以是小写。

### 浮点常量

浮点常量由整数部分、小数部分、小数点和指数部分组成。您可以使用小数形式或者指数形式来表示浮点常量。

当使用小数形式表示时，必须包含整数部分、小数部分、或者同时包含两者。当使用指数形式表示时，必须包含小数点、指数、或者同时包含两者。带符号的指数是用e或者E引入的。

下面来列举几个浮点常量的实例：

```
3.14159         //合法的
314159E-5L      //合法的
510E            //非法的，不完整的指数
210f            //非法的，没有小数或者指数
.e55            //非法的，缺少整数或分数
```

### 布尔常量

布尔常量共有两个，他们都是标准的C++关键字：

true代表真 

false代表假 

### 字符常量

字符常量是括在单引号中。如果常量L（仅当以大写时）开头，则表示他是一个宽字符常量（例如L'x'），此时它必须存储在wchar_t类型的变量中。否则它就是一个窄字符常量（例如'x'），此时它可以存储在char类型的简单变量中。

字符常量可以是一个普通的字符（例如'x'）、一个转义序列（例如'\t'）,或一个通用的字符（例如'\u02C0'）。

### 字符串常量

字符串字面值或常量是括在双引号中的。一个字符串包含类似于字符常量的字符：普通的字符、转义序列和通用的字符。

您可以用空格做分割符，把一个很长的字符串常量进行分行。

### 定义常量

在c++中，有两种简单的定义常量的方式。

1、使用#define预处理器

2、使用const关键字

### #define预处理器

```
#define number 6
```

### conse关键字

```
const int a = 6 
```

### 注意

把常量定义为大写字母形式，是一个很好的编程实践。

## C++修饰符类型

c++允许在char、int、和double数据类型前放置修饰符。

修饰符用于改变基本类型的含义，所以它更能满足各种情景的需求

下面列出了数据类型修饰符：

- signed           //可应用于整形，字符型，也可以作为long，short修饰符的前缀
- unsigned      //可应用于整形，字符型，也可以作为long，short修饰符的前缀
- long              //可应用于整形，双精度浮点型
- short            //可应用于整形

c++允许用速记符号来声明无符号短整数和无符号长整数。您可以不写int，只写单词unsigned、short

或unsigned、long、int是隐含的。

### c++中的类型运算符

类型运算符提供了变量的额外信息

- const         //const类型的对象在程序执行期间不能被修改改变
- volatile      //修饰符volatile告诉编译器不需要优化volatile声明的变量，让程序可以直接从内存中读取变量。对于一般的变量编辑器会对变量进行优化，将内存中的变量值放在寄存器中以加快读写效率。
- restrict      //由restrict修饰的指针是唯一一种访问它所指向的对象的方式。只有C99增加了新的类型限定符restrict。

## C++存储类

存储类定义C++程序中**变量/函数的范围(可见性)**和**生命周期**。这些说明符放置在它们所修饰的类型之前。下面列出C++程序中可用的存储类：

- auto
- register
- static
- extern
- mutable
- thread_local(C++11)

从C++17开始，auto关键字不再是C++存储类说明符，且register关键字被弃用。

### auto存储类

自 C++ 11 以来，**auto** 关键字用于两种情况：声明变量时根据初始化表达式自动推断该变量的类型、声明函数时函数返回值的占位符。

C++98标准中auto关键字用于自动变量的声明，但由于使用极少且多余，在C++11中已删除这一用法。

根据初始化表达式自动推断被声明的变量的类型。

### regist存储类

register存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个词），且不能对它应用一元的 '&' 运算符（因为它没有内存位置）。

寄存器只用于需要快速访问的变量，比如计数器。还应注意的是，定义 'register' 并不意味着变量将被存储在寄存器中，它意味着变量可能存储在寄存器中，这取决于硬件和实现的限制。

### static存储类

**static** 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。

static 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。

在 C++ 中，当 static 用在类数据成员上时，会导致仅有一个该成员的副本被类的所有对象共享。

### extern存储类

**extern** 存储类用于提供一个全局变量的引用，全局变量对**所有的程序文件**都是可见的。当您使用 'extern' 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。

当您有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 *extern* 来得到已定义的变量或函数的引用。可以这么理解，***extern* 是用来在另一个文件中声明一个全局变量或函数。**

extern 修饰符通常用于**当有两个或多个文件共享相同的全局变量或函数的时候**。

### mutable存储类

**mutable** 说明符仅适用于类的对象，它允许对象的成员替代常量。也就是说，mutable 成员可以通过 const 成员函数修改。

### thread_local存储类

使用 thread_local 说明符声明的变量仅可在它在其上创建的线程上访问。 变量在创建线程时创建，并在销毁线程时销毁。 每个线程都有其自己的变量副本。

thread_local 说明符可以与 static 或 extern 合并。

可以将 thread_local 仅应用于数据声明和定义，thread_local 不能用于函数声明或定义。

## C++运算符

### 算数运算符

```
 +      加
 -      减
 *      乘
 /      除
 %      取模
 ++     自增
 --     自减
```



### 关系运算符

```
==      检查两个操作数是否相等
!=      检查连个操作数是否不等
<       判断小于
>       判断大于
>=      判断大于等于
<=      判断小于等于
```

### 逻辑运算符

```
&&      逻辑与运算
||      逻辑或运算
!       逻辑非运算
```

### 位运算符

位运算符作用于位，并逐位执行操作。

```
&            与
|            或
^            异或
~            按位取反，1变成0,0变成1
<<           左操作数的值向左移动右操作数指定的位数
>>           左操作数的值向右移动右操作数指定的位数
```

### 赋值运算符

```
=            把右操作数的值赋给左操作数
+=           
-=
*=
/=
%=
<<=
>>=
&=
^=
|=
```

### 杂项运算符

```
sizeof              返回变量大小
 ? :                三目运算
 ，                 逗号运算符，会顺序地执行，整个逗号表达式的值是整个列表中最后一个表达式的值
.(点)和->(箭头)      成员运算符用于引用类、结构和共用体的成员      
Cast                强制类型转换符，例子（int）a
&                   地址符，返回地址
*                   指针运算符，指向一个变量
```

## C++循环

### 循环类型

```
for(   ;   ;   )
while(      )
do...while
嵌套循环
```

### 循环控制语句

```
break             终止loop或者switch语句
continue          引起循环跳过主体的剩余部分，立即重新开始测试条件
goto              将控制转移到被标记的语句（ 不建议使用）
```

### 无线循环

您可以按ctrl + c来终止一个无限循环

## C++判断

```
if
if...else
switch
```

## C++函数

C++ 标准库提供了大量的程序可以调用的内置函数。例如，函数 **strcat()** 用来连接两个字符串，函数 **memcpy()** 用来复制内存到另一个位置。

### 函数参数

```
调用类型

传值调用 	该方法把参数的实际值赋值给函数的形式参数。在这种情况下，修改函数内的形式参数对实际参数没有影响
指针调用    该方法把参数的地址赋值给形式参数。在函数内，该地址用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。
引用调用    该方法把参数的引用赋值给形式参数。在函数内，该引用用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。
```

### Lambda函数与表达式

C++11 提供了对匿名函数的支持,称为 Lambda 函数(也叫 Lambda 表达式)。 

Lambda 表达式把函数看作对象。Lambda 表达式可以**像对象一样使用**，比如可以将它们赋给变量和作为参数传递，还可以像函数一样对其求值。

**Lambda 表达式本质上与函数声明非常类似**。Lambda 表达式具体形式如下:

```
[capture](parameters)->return-type{body}
例如：
[](int x, int y){return x < y ;}
没有返回值可以表示为
[capture](parameters){body}
例如：
[]{++global_x;}
```

如果 lambda 函数没有传回值（例如 void），其返回类型可被完全忽略。

在Lambda表达式内可以访问当前作用域的变量，这是Lambda表达式的闭包（Closure）行为。 与JavaScript闭包不同，C++变量传递有传值和传引用的区别。可以通过前面的[]来指定：

```
[]      // 沒有定义任何变量。使用未定义变量会引发错误。
[x, &y] // x以传值方式传入（默认），y以引用方式传入。
[&]     // 任何被使用到的外部变量都隐式地以引用方式加以引用。
[=]     // 任何被使用到的外部变量都隐式地以传值方式加以引用。
[&, x]  // x显式地以传值方式加以引用。其余变量以引用方式加以引用。
[=, &z] // z显式地以引用方式加以引用。其余变量以传值方式加以引用。
```

另外有一点需要注意。对于[=]或[&]的形式，lambda 表达式可以直接使用 this 指针。但是，对于[]的形式，如果要使用 this 指针，必须显式传入：

```
[this]() { this->someFunc(); }();
```

## C++数学

### c++数学运算

```
double cos(double);                   该函数返回弧度角（double 型）的余弦。
double sin(double);                   该函数返回弧度角（double 型）的正弦。
double tan(double);                   该函数返回弧度角（double 型）的正切。
double log(double);                   该函数返回参数的自然对数。
double pow(double,double);            该函数返回 x 的 y 次方。
double hypot(double,double);          该函数返回两个参数的平方总和的平方根。
double sqrt(double);                  该函数返回参数的平方根。
int abs(int);                         该函数返回整数的绝对值。
double fabs(double);                  该函数返回任意一个浮点数的绝对值。
double floor(double);                 该函数返回一个小于或等于传入参数的最大整数。
```

### c++随机数

在许多情况下，需要生成随机数。关于**随机数生成器**，有两个相关的函数。一个是 **rand()**，该函数只返回一个伪随机数。生成随机数之前必须先调用 **srand()** 函数。

下面是一个关于生成随机数的简单实例。实例中使用了 **time()** 函数来获取系统时间的秒数，通过调用 rand() 函数来生成随机数：

```
#include <iostream>
#include <ctime>
#include <cstdlib>
 
using namespace std;   //分配工作空间
 
int main ()
{
   int i,j;
 
   // 设置种子
   srand( (unsigned)time( NULL ) );
 
   /* 生成 10 个随机数 */
   for( i = 0; i < 10; i++ )
   {
      // 生成实际的随机数
      j= rand();
      cout <<"随机数： " << j << endl;
   }
 
   return 0;
}

```

## C++数组

C++ 支持**数组**数据结构，它可以存储一个固定大小的相同类型元素的顺序集合。数组是用来存储一系列数据，但它往往被认为是一系列相同类型的变量。

### 声明数组

在 C++ 中要声明一个数组，需要指定元素的类型和元素的数量，如下所示：

```
type arrayName [ arraySize ];
```

### 初始化数组

在 C++ 中，您可以逐个初始化数组，也可以使用一个初始化语句，如下所示：

```
double balance[5] = {1000.0, 2.0, 3.4, 7.0, 50.0};
```

### 访问数组元素

数组元素可以通过数组名称加索引进行访问。元素的索引是放在方括号内，跟在数组名称的后边。例如：

```
double salary = balance[9];
```

### 使用函数操作数组

```
strcpy(s1,s2);          复制字符串 s2 到字符串 s1。
strcat(s1,s2);             连接字符串 s2 到字符串 s1 的末尾。
strlen(s1);             返回字符串 s1 的长度。
strcmp(s1,s2);          如果s1和s2是相同的，则返 0；如果s1<s2则返回值小于0如果s1>s2则返回值大于0。
strchr(s1,ch);          返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。
strstr(s1,s2);          返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。
```

### C++ 中的 String 类

C++ 标准库提供了 **string** 类类型，支持上述所有的操作，另外还增加了其他更多的功能。我们将学习 C++ 标准库中的这个类。

## C++指针

### NULL空指针

在变量声明的时候，如果没有确切的地址可以赋值，为指针变量赋一个 NULL 值是一个良好的编程习惯。赋为 NULL 值的指针被称为**空指针**。

NULL 指针是一个定义在标准库中的值为零的常量。

在大多数的操作系统上，**程序不允许访问地址为 0 的内存**，因为该内存是操作系统保留的。然而，内存地址 0 有特别重要的意义，它**表明该指针不指向一个可访问的内存位置**。但按照惯例，如果指针包含空值（零值），则假定它不指向任何东西。

## C++引用

**定义**：引用变量是一个别名，也就是说，它是某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。

### 引用与指针的不同

1. 不存在空引用，引用必须连接到一块合法的内存。
2. 一旦引用被初始化为一个对象，就不能被指向到另一个对象，指针可以在任何时候指向到另一个对象。
3. 引用必须在创建时被初始化。指针可以在任何时候被初始化。

### c++中创建引用

试想变量名称是变量附属在内存位置中的标签，您可以把引用当成是变量附属在内存位置中的第二个标签。因此，您可以通过原始变量名称或引用来访问变量的内容。

```
例如：
int i = 17;
int&  r = i;
double& s = d;
```

在这些声明中，& 读作**引用**。因此，第一个声明可以读作 r 是一个初始化为 i 的整型引用，第二个声明可以读作 s 是一个初始化为 d 的 double 型引用。

引用通常用于函数参数列表和函数返回值。

### 引用的用法

#### 把引用作为参数

C++ 支持把引用作为参数传给函数，这比传一般的参数更安全。

#### 把引用作为返回值

可以从 C++ 函数中返回引用，就像返回其他数据类型一样。

## C++ 基本的输入输出

C++ 的 I/O 发生在流中，**流是字节序列**。如果字节流是从设备（如键盘、磁盘驱动器、网络连接等）流向内存，这叫做**输入操作**。如果字节流是从内存流向设备（如显示屏、打印机、磁盘驱动器、网络连接等），这叫做**输出操作**。

### I/O 库头文件标准输出流（cout）

预定义的对象 **cout** 是 **iostream** 类的一个实例。cout 对象"连接"到标准输出设备，通常是显示屏。**cout** 是与流插入运算符 << 结合使用的，如下所示：

```
cout << "Value of str is : " << str << endl;
```

C++ 编译器根据要输出变量的数据类型，选择合适的流插入运算符来显示值。<< 运算符被重载来输出内置类型（整型、浮点型、double 型、字符串和指针）的数据项。

流插入运算符 << 在一个语句中可以多次使用，如上面实例中所示，**endl** 用于在行末添加一个换行符。

### 标准输入流（cin)

预定义的对象 **cin** 是 **iostream** 类的一个实例。cin 对象附属到标准输入设备，通常是键盘。**cin** 是与流提取运算符 >> 结合使用的

```
例：
 cin >> name;
```

C++ 编译器根据要输入值的数据类型，选择合适的流提取运算符来提取值，并把它存储在给定的变量中。

流提取运算符 >> 在一个语句中可以多次使用，如果要求输入多个数据，可以使用如下语句

```
cin >> name >> age;
```

### 标准错误流（cerr）

预定义的对象 **cerr** 是 **iostream** 类的一个实例。cerr 对象附属到标准错误设备，通常也是显示屏，但是 **cerr** 对象是非缓冲的，且每个流插入到 cerr 都会立即输出。

**cerr** 也是与流插入运算符 << 结合使用的，如下所示：

```
cerr << "Error message : " << str << endl;
```

### 标准日志流（clog）

预定义的对象 **clog** 是 **iostream** 类的一个实例。clog 对象附属到标准错误设备，通常也是显示屏，但是 **clog** 对象是缓冲的。这意味着每个流插入到 clog 都会先存储在缓冲区，直到缓冲填满或者缓冲区刷新时才会输出。

**clog** 也是与流插入运算符 << 结合使用的

### 总结

通过这些小实例，我们无法区分 cout、cerr 和 clog 的差异，但在编写和执行大型程序时，它们之间的差异就变得非常明显。所以良好的编程实践告诉我们，使用 cerr 流来显示错误消息，而其他的日志消息则使用 clog 流来输出。

## C++数据结构

C/C++ 数组允许定义可存储相同类型数据项的变量，但是**结构**是 C++ 中另一种用户自定义的可用的数据类型，它允许您存储不同类型的数据项。

### 定义结构

```
struct type_name{
member_type1 member_name1;
member_type2 member_name2;
member_type3 member_name3;
.
.
}object_name;
```

### 访问结构成员

为了访问结构的成员，我们使用**成员访问运算符（.）**。成员访问运算符是结构变量名称和我们要访问的结构成员之间的一个句号。

```
strcpy( Book1.title, "C++ 教程");
```

### 结构作为函数参数

您可以把结构作为函数参数，传参方式与其他类型的变量或指针类似。

### 指向结构的指针

您可以定义指向结构的指针，方式与定义指向其他类型变量的指针相似

```
struct Books *struct_pointer;
```

现在，您可以在上述定义的指针变量中存储结构变量的地址。为了查找结构变量的地址，请把 & 运算符放在结构名称的前面

```
struct_pointer = &Book1;
```

为了使用指向该结构的指针访问结构的成员，您必须使用 -> 运算符

```
struct_pointer->title;
```

### typedef 关键字

下面是一种更简单的定义结构的方式，您可以为创建的类型取一个"别名"。

```
typedef struct Books
{
   char  title[50];
   char  author[50];
   char  subject[100];
   int   book_id;
}Books;
```

现在，您可以直接使用 *Books* 来定义 *Books* 类型的变量，而不需要使用 struct 关键字。

```
Books Book1, Book2;
```

## C++类与对象

### 类的定义

类用于指定对象的形式，它包含了数据表示法和用于处理数据的方法。类中的数据和方法称为类的成员。函数在一个类中被称为类的成员。

定义一个类，本质上是定义一个数据类型的蓝图。这实际上并没有定义任何数据，但它定义了类的名称意味着什么，也就是说，它定义了类的对象包括了什么，以及可以在这个对象上执行哪些操作。

类定义是以关键字 **class** 开头，后跟类的名称。类的主体是包含在一对花括号中。类定义后必须跟着一个分号或一个声明列表。

例如，我们使用关键字 **class** 定义 Box 数据类型，如下所示：

```
class Box
{
   public:             //表示公共成员在类的外部是可访问的
      double length;   // 盒子的长度
      double breadth;  // 盒子的宽度
      double height;   // 盒子的高度
};
```

关键字 **public** 确定了类成员的访问属性。在类对象作用域内，公共成员在类的外部是可访问的。您也可以指定类的成员为 **private** 或 **protected**，这个我们稍后会进行讲解。

### 定义C++对象

类提供了对象的蓝图，所以基本上，对象是根据类来创建的。声明类的对象，就像声明基本类型的变量一样。下面的语句声明了类 Box 的两个对象：

```
Box Box1;          // 声明 Box1，类型为 Box
Box Box2;          // 声明 Box2，类型为 Box
```

### 访问数据成员

类的对象的公共数据成员可以使用直接成员访问运算符 (.) 来访问。

```
Box1.height = 5.0; 
```

需要注意的是，私有的成员和受保护的成员不能使用直接成员访问运算符 (.) 来直接访问。

### 类&对象详解

#### 类成员函数

**类的成员函数**是指那些把**定义和原型写在类定义内部的函数**，就像类定义中的其他变量一样。类成员函数是类的一个成员，它可以操作类的任意对象，可以访问对象中的所有成员。让我们看看之前定义的类 Box，现在我们**要使用成员函数来访问类的成员**，而不是直接访问这些类的成员：

```
class Box
{
   public:
      double length;         // 长度
      double breadth;        // 宽度
      double height;         // 高度
      double getVolume(void);// 返回体积
};
```

成员函数可以定义在类定义内部，或者单独使用**范围解析运算符 ::** 来定义。在类定义中定义的成员函数把函数声明为**内联**的，即便没有使用 inline 标识符。所以您可以按照如下方式定义 **Volume()** 函数：

```
class Box
{
   public:
      double length;      // 长度
      double breadth;     // 宽度
      double height;      // 高度
   
      double getVolume(void)
      {
         return length * breadth * height;
      }
};
```

您也可以在类的外部使用**范围解析运算符 ::** 定义该函数，如下所示：

```
double Box::getVolume(void)
{
    return length * breadth * height;
}
```

在这里，需要强调一点，在 :: 运算符之前必须使用类名。调用成员函数是在对象上使用点运算符（**.**），这样它就能操作与该对象相关的数据，如下所示：

```
Box myBox;          // 创建一个对象 
myBox.getVolume();  // 调用该对象的成员函数
```

#### 类访问修饰符

##### 公有(public)成员

**公有**成员在程序中类的外部是可访问的。您可以不使用任何成员函数来设置和获取公有变量的值。

此时，无论使用引用还是使用成员函数都能访问这些数据。

##### 私有（private）成员

**私有**成员变量或函数在类的外部是不可访问的，甚至是不可查看的。只有类和友元函数可以访问私有成员。

默认情况下，类的所有成员都是私有的。例如在下面的类中，**width** 是一个私有成员，这意味着，如果您没有使用任何访问修饰符，类的成员将被假定为私有成员。

实际操作中，我们一般会在私有区域定义数据，在公有区域定义相关的函数，以便在类的外部也可以调用这些函数，如下所示：

```
class Box
{
   public:
      double length;
      void setWidth( double wid );
      double getWidth( void );
 
   private:
      double width;
};
 
// 成员函数定义
double Box::getWidth(void)
{
    return width ;
}
 
void Box::setWidth( double wid )
{
    width = wid;
}
```

此时，无法通过引用直接访问私有成员，但是可以通过成员函数访问私有成员。

##### 保护（protected）成员

**保护**成员变量或函数与私有成员十分相似，但有一点不同，保护成员在派生类（即子类）中是可访问的。

在下一个章节中，您将学习到派生类和继承的知识。现在您可以看到下面的实例中，我们从父类 **Box** 派生了一个子类 **smallBox**。

下面的实例与前面的实例类似，在这里 **width** 成员可被派生类 smallBox 的任何成员函数访问。

### c++友元函数

类的友元函数是定义在类外部，但有权访问类的所有私有（private）成员和保护（protected）成员。尽管友元函数的原型有在类的定义中出现过，但是友元函数并不是成员函数。

友元可以是一个函数，该函数被称为友元函数；友元也可以是一个类，该类被称为友元类，在这种情况下，整个类及其所有成员都是友元。

如果要声明函数为一个类的友元，需要在类定义中该函数原型前使用关键字 **friend**，如下所示：

```
class Box
{
   double width;
public:
   double length;
   friend void printWidth( Box box );
   void setWidth( double wid );
};
```

声明类 ClassTwo 的所有成员函数作为类 ClassOne 的友元，需要在类 ClassOne 的定义中放置如下声明：

```
friend class ClassTwo;
```

### c++内联函数

C++ **内联函数**是通常与类一起使用。如果一个函数是内联的，那么在编译时，编译器会**把该函数的代码副本放置在每个调用该函数的地方。**

对内联函数进行任何修改，都需要重新编译函数的所有客户端，因为编译器需要重新更换一次所有的代码，否则将会继续使用旧的函数。

如果想把一个函数定义为内联函数，则需要在函数名前面放置关键字 **inline**，在调用函数之前需要对函数进行定义。如果已定义的函数多于一行，编译器会忽略 inline 限定符。

在类定义中的定义的函数都是内联函数，即使没有使用 **inline** 说明符。

##### 目的

引入内联函数的目的是为了**解决程序中函数调用的效率问题**，这么说吧，程序在编译器编译的时候，编译器将程序中出现的内联函数的调用表达式用内联函数的函数体进行替换，而对于其他的函数，都是在运行时候才被替代。这其实就是个空间代价换时间的i节省。所以内联函数一般都是1-5行的小函数。在使用内联函数时要留神：

- 1.在内联函数内不允许使用循环语句和开关语句；
- 2.内联函数的定义必须出现在内联函数第一次调用之前；
- 3.类结构中所在的类说明内部定义的函数是内联函数。

### C++ this 指针

在 C++ 中，每一个对象都能通过 **this** 指针来访问自己的地址。**this** 指针是所有成员函数的隐含参数。因此，在成员函数内部，它可以用来指向调用对象。

友元函数没有 **this** 指针，因为友元不是类的成员。只有成员函数才有 **this** 指针。

### C++ 指向类的指针

一个指向 C++ 类的指针与指向结构的指针类似，访问指向类的指针的成员，需要使用成员访问运算符 **->**，就像访问指向结构的指针一样。与所有的指针一样，您必须在使用指针之前，对指针进行初始化。

### C++ 类的静态成员

#### 定义

我们可以使用 **static** 关键字来把类成员定义为静态的。当我们声明类的成员为静态时，这意味着无论创建多少个类的对象，静态成员都只有一个副本。

**静态成员在类的所有对象中是共享的**。如果不存在其他的初始化语句，在创建第一个对象时，所有的静态数据都会被初始化为零。我们不能把静态成员的初始化放置在类的定义中，但是可以在类的外部通过使用范围解析运算符 **::** 来重新声明静态变量从而对它进行初始化。

**同一名称类只能声明一次**

#### 静态成员函数

如果把函数成员声明为静态的，就可以把函数与类的任何特定对象独立开来。静态成员函数即使在类对象不存在的情况下也能被调用，**静态函数**只要**使用类名加范围解析运算符 :: 就可以访问**。

静态成员函数只能访问静态成员数据、其他**静态成员函数和类外部的其他函数。**

静态成员函数有一个类范围，他们不能访问类的 this 指针。您**可以使用静态成员函数来判断类的某些对象是否已被创建。**

> **静态成员函数与普通成员函数的区别：**
>
> - 静态成员函数没有 this 指针，只能访问静态成员（包括静态成员变量和静态成员函数）。
> - 普通成员函数有 this 指针，可以访问类中的任意成员；而静态成员函数没有 this 指针。

## C++继承

### 继承定义

面向对象程序设计中最重要的一个概念是继承。继承允许我们**依据另一个类来定义一个类**，这使得创建和维护一个应用程序变得更容易。这样做，也达到了**重用代码功能**和**提高执行效率**的效果。

当创建一个类时，您不需要重新编写新的数据成员和成员函数，只需指定新建的类继承了一个已有的类的成员即可。这个已有的类称为**基类**，新建的类称为**派生类**。

### 基类 & 派生类

一个类可以派生自多个类，这意味着，它可以从多个基类继承数据和函数。定义一个派生类，我们使用一个类派生列表来指定基类。类派生列表以一个或多个基类命名，形式如下：

```
class derived-class: access-specifier base-class
```

其中，访问修饰符 access-specifier 是 **public、protected** 或 **private** 其中的一个，base-class 是之前定义过的某个类的名称。如果未使用访问修饰符 access-specifier，则默认为 private。

### 访问控制和继承

派生类可以访问基类中所有的非私有成员。因此基类成员如果不想被派生类的成员函数访问，则应在基类中声明为 private。

我们可以根据访问权限总结出不同的访问类型，如下所示：

| 访问     | public | protected | private |
| -------- | ------ | --------- | ------- |
| 同一个类 | yes    | yes       | yes     |
| 派生类   | yes    | yes       | no      |
| 外部的类 | yes    | no        | no      |

一个派生类继承了所有的基类方法，但下列情况除外：

- 基类的构造函数、析构函数和拷贝构造函数。
- 基类的重载运算符。
- 基类的友元函数。

### 继承类型

当一个类派生自基类，该基类可以被继承为 **public、protected** 或  **private** 几种类型。继承类型是通过上面讲解的访问修饰符 access-specifier 来指定的。

我们几乎不使用 **protected** 或  **private** 继承，通常使用 **public** 继承。当使用不同类型的继承时，遵循以下几个规则：

- **公有继承（public）：**当一个类派生自**公有**基类时，基类的**公有**成员也是派生类的**公有**成员，基类的**保护**成员也是派生类的**保护**成员，基类的**私有**成员不能直接被派生类访问，但是可以通过调用基类的**公有**和**保护**成员来访问。
- **保护继承（protected）：** 当一个类派生自**保护**基类时，基类的**公有**和**保护**成员将成为派生类的**保护**成员。
- **私有继承（private）：**当一个类派生自**私有**基类时，基类的**公有**和**保护**成员将成为派生类的**私有**成员。

### 多继承

多继承即一个子类可以有多个父类，它继承了多个父类的特性。

C++ 类可以从多个类继承成员，语法如下：

```
class <派生类名>:<继承方式1><基类名1>,<继承方式2><基类名2>,…
{
<派生类类体>
};
```

## C++ 重载运算符和重载函数

### 重载定义

C++ 允许在同一作用域中的某个**函数**和**运算符**指定多个定义，分别称为**函数重载**和**运算符重载**。

重载声明是指一个与之前**已经在该作用域内声明过的函数或方法**具有相同名称的声明，但是它们的**参数列表和定义（实现）不相同。**

当您调用一个**重载函数**或**重载运算符**时，**编译器**通过把您所使用的参数类型与定义中的参数类型进行比较，决定选用最合适的定义。**选择最合适**的重载函数或重载运算符的过程，称为**重载决策**。

### C++ 中的函数重载

在同一个作用域内，可以声明几个功能类似的同名函数，但是这些**同名函数的形式参数（指参数的个数、类型或者顺序）必须不同**。您**不能**仅通过**返回类型的不同来重载函数。**

下面的实例中，同名函数 **print()** 被用于输出不同的数据类型：

```
#include <iostream>
using namespace std;

class printData
{
   public:
      void print(int i) {
        cout << "整数为: " << i << endl;
      }
 
      void print(double  f) {
        cout << "浮点数为: " << f << endl;
      }
 
      void print(char c[]) {
        cout << "字符串为: " << c << endl;
      }
};
 
int main(void)
{
   printData pd;
 
   // 输出整数
   pd.print(5);
   // 输出浮点数
   pd.print(500.263);
   // 输出字符串
   char c[] = "Hello C++";
   pd.print(c);
 
   return 0;
}
```

### C++ 中的运算符重载

您可以重定义或重载大部分 C++ 内置的运算符。这样，您就能使用**自定义类型的运算符**。

**重载的运算符**是**带有特殊名称的函数**，函数名是由关键字 **operator** 和其后要重载的运算符符号构成的。与其他函数一样，重载运算符有一个返回类型和一个参数列表。

```
Box operator+(const Box&);
```

声明加法运算符用于把两个 Box 对象相加，返回最终的 Box 对象。大多数的重载运算符可被定义为普通的非成员函数或者被定义为类成员函数。如果我们定义上面的函数为类的非成员函数，那么我们需要为每次操作传递两个参数，如下所示：

```
Box operator+(const Box&, const Box&);
```

下面的实例使用成员函数演示了运算符重载的概念。在这里，对象作为参数进行传递，对象的属性使用 **this** 运算符进行访问。

### 可重载运算符/不可重载运算符

下面是可重载的运算符列表：

| 双目算术运算符 | + (加)，-(减)，*(乘)，/(除)，% (取模)                        |
| -------------- | ------------------------------------------------------------ |
| 关系运算符     | ==(等于)，!= (不等于)，< (小于)，> (大于>，<=(小于等于)，>=(大于等于) |
| 逻辑运算符     | \|\|(逻辑或)，&&(逻辑与)，!(逻辑非)                          |
| 单目运算符     | + (正)，-(负)，*(指针)，&(取地址)                            |
| 自增自减运算符 | ++(自增)，--(自减)                                           |
| 位运算符       | \| (按位或)，& (按位与)，~(按位取反)，^(按位异或),，<< (左移)，>>(右移) |
| 赋值运算符     | =, +=, -=, *=, /= , % = , &=, \|=, ^=, <<=, >>=              |
| 空间申请与释放 | new, delete, new[ ] , delete[]                               |
| 其他运算符     | ()(函数调用)，->(成员访问)，,(逗号)，[](下标)                |

下面是不可重载的运算符列表：

- .：成员访问运算符
- .*, ->*：成员指针访问运算符
- ::：域运算符
- sizeof：长度运算符
- ?:：条件运算符
- \#： 预处理符号

## C++多态

### 定义

**多态**按字面的意思就是多种形态。当类之间存在层次结构，并且类之间是通过继承关联时，就会用到多态。

C++ 多态意味着调用成员函数时，会根据**调用函数的对象的类型来执行不同的函数。**

### 虚函数

**虚函数** 是在基类中使用关键字 **virtual** 声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。

我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为**动态链接**，或**后期绑定**。

### 纯虚函数

您可能想要在基类中定义虚函数，以便在派生类中重新定义该函数更好地适用于对象，但是您在基类中又不能对虚函数给出有意义的实现，这个时候就会用到纯虚函数。

## C++ 数据抽象