# C++

## 变量

### 全局变量

**定义：**在所有函数的外部声明的变量，称为全局变量。

### 局部变量

**定义：**在函数或一个代码块内部声明的变量，称为局部变量。

### 形式参数

**定义：**在函数参数的定义中声明的变量，称为形式参数。

## 常量

**定义：**1、常量是固定值，在程序执行期间不会改变，这些固定的值，称作字面量。

2、常量可以是任何的基本数据类型，可分为整形数字、字符、字符串或者布尔值。

3、常量就像是常规的变量，只不过常量的值在定义后不能修改。

### 整形常量

整形常量可以是十进制，八进制或十六进制的常量。

前缀制定基数：0x或0X表示16进制，0表示八进制，不带前缀则默认表示十进制。

整数常量也可以带一个后缀，后缀是U和L的组合，U表示无符号整数（

unsigned），L表示长整数（long）。

后缀可以使大写也可以是小写。

### 浮点常量

浮点常量由整数部分、小数部分、小数点和指数部分组成。您可以使用小数形式或者指数形式来表示浮点常量。

当使用小数形式表示时，必须包含整数部分、小数部分、或者同时包含两者。当使用指数形式表示时，必须包含小数点、指数、或者同时包含两者。带符号的指数是用e或者E引入的。

下面来列举几个浮点常量的实例：

```
3.14159         //合法的
314159E-5L      //合法的
510E            //非法的，不完整的指数
210f            //非法的，没有小数或者指数
.e55            //非法的，缺少整数或分数
```

### 布尔常量

布尔常量共有两个，他们都是标准的C++关键字：

true代表真 

false代表假 

### 字符常量

字符常量是括在单引号中。如果常量L（仅当以大写时）开头，则表示他是一个宽字符常量（例如L'x'），此时它必须存储在wchar_t类型的变量中。否则它就是一个窄字符常量（例如'x'），此时它可以存储在char类型的简单变量中。

字符常量可以是一个普通的字符（例如'x'）、一个转义序列（例如'\t'）,或一个通用的字符（例如'\u02C0'）。

### 字符串常量

字符串字面值或常量是括在双引号中的。一个字符串包含类似于字符常量的字符：普通的字符、转义序列和通用的字符。

您可以用空格做分割符，把一个很长的字符串常量进行分行。

### 定义常量

在c++中，有两种简单的定义常量的方式。

1、使用#define预处理器

2、使用const关键字

### #define预处理器

```
#define number 6
```

### conse关键字

```
const int a = 6 
```

### 注意

把常量定义为大写字母形式，是一个很好的编程实践。

## C++修饰符类型

c++允许在char、int、和double数据类型前放置修饰符。

修饰符用于改变基本类型的含义，所以它更能满足各种情景的需求

下面列出了数据类型修饰符：

- signed           //可应用于整形，字符型，也可以作为long，short修饰符的前缀
- unsigned      //可应用于整形，字符型，也可以作为long，short修饰符的前缀
- long              //可应用于整形，双精度浮点型
- short            //可应用于整形

c++允许用速记符号来声明无符号短整数和无符号长整数。您可以不写int，只写单词unsigned、short

或unsigned、long、int是隐含的。

### c++中的类型运算符

类型运算符提供了变量的额外信息

- const         //const类型的对象在程序执行期间不能被修改改变
- volatile      //修饰符volatile告诉编译器不需要优化volatile声明的变量，让程序可以直接从内存中读取变量。对于一般的变量编辑器会对变量进行优化，将内存中的变量值放在寄存器中以加快读写效率。
- restrict      //由restrict修饰的指针是唯一一种访问它所指向的对象的方式。只有C99增加了新的类型限定符restrict。

## C++存储类

存储类定义C++程序中**变量/函数的范围(可见性)**和**生命周期**。这些说明符放置在它们所修饰的类型之前。下面列出C++程序中可用的存储类：

- auto
- register
- static
- extern
- mutable
- thread_local(C++11)

从C++17开始，auto关键字不再是C++存储类说明符，且register关键字被弃用。

### auto存储类

自 C++ 11 以来，**auto** 关键字用于两种情况：声明变量时根据初始化表达式自动推断该变量的类型、声明函数时函数返回值的占位符。

C++98标准中auto关键字用于自动变量的声明，但由于使用极少且多余，在C++11中已删除这一用法。

根据初始化表达式自动推断被声明的变量的类型。

### regist存储类

register存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个词），且不能对它应用一元的 '&' 运算符（因为它没有内存位置）。

寄存器只用于需要快速访问的变量，比如计数器。还应注意的是，定义 'register' 并不意味着变量将被存储在寄存器中，它意味着变量可能存储在寄存器中，这取决于硬件和实现的限制。

### static存储类

**static** 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。

static 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。

在 C++ 中，当 static 用在类数据成员上时，会导致仅有一个该成员的副本被类的所有对象共享。

### extern存储类

**extern** 存储类用于提供一个全局变量的引用，全局变量对**所有的程序文件**都是可见的。当您使用 'extern' 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。

当您有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 *extern* 来得到已定义的变量或函数的引用。可以这么理解，***extern* 是用来在另一个文件中声明一个全局变量或函数。**

extern 修饰符通常用于**当有两个或多个文件共享相同的全局变量或函数的时候**。

### mutable存储类

**mutable** 说明符仅适用于类的对象，它允许对象的成员替代常量。也就是说，mutable 成员可以通过 const 成员函数修改。

### thread_local存储类

使用 thread_local 说明符声明的变量仅可在它在其上创建的线程上访问。 变量在创建线程时创建，并在销毁线程时销毁。 每个线程都有其自己的变量副本。

thread_local 说明符可以与 static 或 extern 合并。

可以将 thread_local 仅应用于数据声明和定义，thread_local 不能用于函数声明或定义。

## C++运算符

### 算数运算符

```
 +      加
 -      减
 *      乘
 /      除
 %      取模
 ++     自增
 --     自减
```



### 关系运算符

```
==      检查两个操作数是否相等
!=      检查连个操作数是否不等
<       判断小于
>       判断大于
>=      判断大于等于
<=      判断小于等于
```

### 逻辑运算符

```
&&      逻辑与运算
||      逻辑或运算
!       逻辑非运算
```

### 位运算符

位运算符作用于位，并逐位执行操作。

```
&            与
|            或
^            异或
~            按位取反，1变成0,0变成1
<<           左操作数的值向左移动右操作数指定的位数
>>           左操作数的值向右移动右操作数指定的位数
```

### 赋值运算符

```
=            把右操作数的值赋给左操作数
+=           
-=
*=
/=
%=
<<=
>>=
&=
^=
|=
```

### 杂项运算符

```
sizeof              返回变量大小
 ? :                三目运算
 ，                 逗号运算符，会顺序地执行，整个逗号表达式的值是整个列表中最后一个表达式的值
.(点)和->(箭头)      成员运算符用于引用类、结构和共用体的成员      
Cast                强制类型转换符，例子（int）a
&                   地址符，返回地址
*                   指针运算符，指向一个变量
```

## C++循环

### 循环类型

```
for(   ;   ;   )
while(      )
do...while
嵌套循环
```

### 循环控制语句

```
break             终止loop或者switch语句
continue          引起循环跳过主体的剩余部分，立即重新开始测试条件
goto              将控制转移到被标记的语句（ 不建议使用）
```

### 无线循环

您可以按ctrl + c来终止一个无限循环

## C++判断

```
if
if...else
switch
```

## C++函数

C++ 标准库提供了大量的程序可以调用的内置函数。例如，函数 **strcat()** 用来连接两个字符串，函数 **memcpy()** 用来复制内存到另一个位置。

### 函数参数

```
调用类型

传值调用 	该方法把参数的实际值赋值给函数的形式参数。在这种情况下，修改函数内的形式参数对实际参数没有影响
指针调用    该方法把参数的地址赋值给形式参数。在函数内，该地址用于访问调用中要用到的实际参数。这意味着，修改形            式参数会影响实际参数。
引用调用    该方法把参数的引用赋值给形式参数。在函数内，该引用用于访问调用中要用到的实际参数。这意味着，修改形            式参数会影响实际参数。
```

### Lambda函数与表达式

C++11 提供了对匿名函数的支持,称为 Lambda 函数(也叫 Lambda 表达式)。 

Lambda 表达式把函数看作对象。Lambda 表达式可以**像对象一样使用**，比如可以将它们赋给变量和作为参数传递，还可以像函数一样对其求值。

**Lambda 表达式本质上与函数声明非常类似**。Lambda 表达式具体形式如下:

```
[capture](parameters)->return-type{body}
例如：
[](int x, int y){return x < y ;}
没有返回值可以表示为
[capture](parameters){body}
例如：
[]{++global_x;}
```

如果 lambda 函数没有传回值（例如 void），其返回类型可被完全忽略。

在Lambda表达式内可以访问当前作用域的变量，这是Lambda表达式的闭包（Closure）行为。 与JavaScript闭包不同，C++变量传递有传值和传引用的区别。可以通过前面的[]来指定：

```
[]      // 沒有定义任何变量。使用未定义变量会引发错误。
[x, &y] // x以传值方式传入（默认），y以引用方式传入。
[&]     // 任何被使用到的外部变量都隐式地以引用方式加以引用。
[=]     // 任何被使用到的外部变量都隐式地以传值方式加以引用。
[&, x]  // x显式地以传值方式加以引用。其余变量以引用方式加以引用。
[=, &z] // z显式地以引用方式加以引用。其余变量以传值方式加以引用。
```

另外有一点需要注意。对于[=]或[&]的形式，lambda 表达式可以直接使用 this 指针。但是，对于[]的形式，如果要使用 this 指针，必须显式传入：

```
[this]() { this->someFunc(); }();
```

## C++数学

### c++数学运算

```
double cos(double);                   该函数返回弧度角（double 型）的余弦。
double sin(double);                   该函数返回弧度角（double 型）的正弦。
double tan(double);                   该函数返回弧度角（double 型）的正切。
double log(double);                   该函数返回参数的自然对数。
double pow(double,double);            该函数返回 x 的 y 次方。
double hypot(double,double);          该函数返回两个参数的平方总和的平方根。
double sqrt(double);
int abs(int);
double fabs(double);
double floor(double);
```

